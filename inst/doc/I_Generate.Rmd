---
title: "GPoM : Generate"
author: "Sylvain Mangiarotti & Mireille Huc"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig.caption: yes
  pdf_document:
    number_sections: no
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
load package: "`r library(GPoM)`"
---

The Generalized Global Polynomial Modelling (GPoM)
package allows a generic
formulation of any Ordinary Differential Equations (ODE)
in polynomial form. The aim of the present vignette
`I_Generate` is to introduce briefly the way to describe
a set of polynomial ODEs in GPoM and how to perform
its numerical integration.


## Convention used to describe a polynomial

The polynomial description is based on a convention defined
in the function `regOrd` that provides the order of the polynomial
terms.
This convention depends on the model dimension (that is the number
`nVar` of state variables), and on the maximum polynomial degree
chosen for the formulation (defined by the parameter `dMax`).
This order can be visualized with the `regLabs` function.
For instance, for `nVar = 3` and `dMax = 2`, the convention used
to formulate a polynomial will be as follows:


```{r}
    poLabs(nVar = 3, dMax = 2)
```

This formulation has `pMax = 10` terms:

```{r, echo=FALSE}
    nVar = 3
    dMax = 2
```
```{r}
    pMax =  d2pMax(nVar, dMax)
```
Based on this convention, one single ordinary differential equation (ODE) in polynomial
form with `nVar` variables and of maximum polynomial degree `dMax` can be formulated
as one single vector using the convention given by `regOrd(nVar, dMax)`.
As an example, the equation :

$dX_1/dt = 1 + 2 X_1 - 3 X_1X_3 + 4 X_2^2$

has three variables (it requires at least `nVar = 3`) and is of maximum polynomial
degree two (it requires at least `dMax = 2`).
Following the convention defined by `regLabs(nVar = 3, dMax = 2)`,
it will require the definition of the following vector of parameter:

```{r}
    param <- c(1, 0, 0, 0, 0, 4, 2, -3, 0, 0)
```

Indeed:
```{r}
    nVar = 3
    dMax = 2
    cbind(param, poLabs(nVar, dMax))
```
The same convention will be used for any other equations.
Note that, by default, notation is `X`.
However, to facilitate the analysis, alternative notations may
also be used using the optional parameter `Xnote`:

```{r}
  poLabs(3, 2, Xnote = 'y')
```

or also:

```{r}
  poLabs(3, 2, Xnote = c('x','W','y'))
```


## Definition of a set of polynomial ODE

A set of $N$ equations will thus require the definition 
of $N$ parameter vectors and will thus be represented
as a matrix of `pMax` lines by `nVar` columns.
For example, the Rössler system^[O. Rössler, An Equation for Continuous Chaos,
Physics Letters, vol. 57A, no 5, 1976, p. 397-398]
is defined by a set of three equations


  $dx/dt = - y - z$

  $dy/dt = x + a y$

  $dz/dt = b + z (x - c)$.


For $(a = 0.52, b = 2, c = 4)$, this system can be decribed
by a matrix `M` built as follows:
```{r}
    # parameters
    a = 0.52
    b = 2
    c = 4
    # equations
    Eq1 <- c(0,-1, 0,-1, 0, 0, 0, 0, 0, 0)
    Eq2 <- c(0, 0, 0, a, 0, 0, 1, 0, 0, 0)
    Eq3 <- c(b,-c, 0, 0, 0, 0, 0, 1, 0, 0)
```
The model formulation is obtained by concatenating the vectors of
the three equations into the matrix `K` that contains all the
coefficients of the model:

```{r}
    K = cbind(Eq1, Eq2, Eq3)
```

The corresponding model equations can be edited in a mathematical
form using the function `visuEq()`

```{r}
    visuEq(nVar, dMax, K)
```

By default, the notation used in `GPoM` is `X` with an index,
such as `X1`, `X2`, etc.
Alternative notation can be used to edit the equations with 
the `visuEq` function by using the option parameter `substit`.
For `substit = 1`, single letters are automatically chosen
such as

```{r}
    visuEq(nVar, dMax, K, substit = 1)
```

The notation can be defined also manually, such as:

```{r, eval=TRUE}
    visuEq(nVar, dMax, K, substit = c("U", "V", "W"))
```

## Numerical integration

The numerical integration of model `M` can be done using
the `numicano` function that requires the use of the external
package `deSolve`.
The following parameters are required:

```{r}
    # The initial conditions of the system variables
    v0 <- c(-0.6, 0.6, 0.4)
    # the model formulation K (see former section)
    # the number of integration steps `Istep`
    # the time step length `onestep`
    # the model dimension `nVar`
    # the maximum polynomial degree `dMax`
```
    
The numerical integration is launched as follows:

```{r}
    outNumi <- numicano(nVar, dMax, Istep = 5000, onestep = 1/50, KL = K, v0 = v0)
```

The output of the function `numicano` is a list that contains
(1) `$K` a memory of the model parameters

```{r, eval=FALSE}
    outNumi$K
```
    
from which `nVar` and `dMax` (required to reformulate the equations)
can be retrieved

```{r, eval = FALSE}
    # nVar
    dim(outNumi$K)[2]
    # dMax
    pMax <- dim(outNumi$K)[1]
    p2dMax(nVar, pMaxKnown = pMax)
```

and (2) the simulations `$reconstr`.
This matrix contains `nVar + 1` columns.
The first one is the time, the other ones correspond
to the variables of the system $(X_1, X_2, X_3, ...)$
that is $(x,y,z)$ in our case.

Note that all other input parameters used in `numicano`
can be retrieved from these output conditions:

```{r, eval=FALSE}    
    # initial conditions
    head(outNumi$reconstr, 1)[2:(nVar+1)]
    # time step
    diff(outNumi$reconstr[1:2,1])
    # number of integration time step
    dim(outNumi$reconstr)[1]
```

The simulated time series can be plotted as follows:

```{r, fig.show='hold', fig.align='center'}    
    plot(outNumi$reconstr[,1], outNumi$reconstr[,2], type='l',
          main='time series', xlab='t', ylab = 'x(t)')
```

and the plot of the phase portrait aswell:

```{r, fig.show='hold', fig.align='center'}  

  plot(outNumi$reconstr[,2], outNumi$reconstr[,3], type='l',
     main='phase portrait', xlab='x(t)', ylab = 'y(t)')
```

## Next steps

The aim of the GPoM package is to retreive ODEs from
time series using global modelling. Such type of modelling
can require a careful data preprocessing.
Simple examples of preprocessing are given in the next
vignette `II_Preprocessing`.
Examples for applying global modelling from time series
will be presented in vignette `III_Modelling`.
