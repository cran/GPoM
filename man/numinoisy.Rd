% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/numinoisy.R
\name{numinoisy}
\alias{numinoisy}
\title{Generates time series of deterministic-behavior
with stochatic perturbations (measurement and/or dynamical noise)}
\usage{
numinoisy(
  x0,
  t,
  K,
  varData = NULL,
  txVarBruitA = NULL,
  txVarBruitM = NULL,
  varBruitA = NULL,
  varBruitM = NULL,
  taux = NULL,
  freq = NULL,
  variables = NULL,
  method = NULL
)
}
\arguments{
\item{x0}{The initial conditions. Should be a vector which size must be equal
to the model dimension \code{dim(K)[2]} (the number of variables of the
model defined by matrix \code{K}).}

\item{t}{A vector providing all the dates for which the output are expected.}

\item{K}{The Ordinary Differential Equations used to model the dynamics.
The number of column should correspond to the number of variables, the
number of lines to the number of parameters following the convention
defined by \code{poLabs(nVar,dMax)}.}

\item{varData}{A vector of size \code{nVar} providing the caracteristic
variances of each variable of the dynamical systems in ODE defined
by matrix \code{K}.
If not provided, this variance is automatically estimated.}

\item{txVarBruitA}{A vector defining the ratio of ADDITIVE noise
for each variable of the dynamical system in ODE. The additive noise is
added at the end of the numerical integration process. The ratio is
defined relatively to the signal variance of each variable.}

\item{txVarBruitM}{A vector defining the ratio of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step. The
ratio is defined relatively to the signal variance of each variable.}

\item{varBruitA}{A vector defining the variance of ADDITIVE noise
for each variable of the dynamical system in ODE. The additive noise is
added at the end of the numerical integration process.}

\item{varBruitM}{A vector defining the variance of DYNAMICAL
noise for each variable of the dynamical system in ODE. This
noise is a perturbation added at each numerical integration step.}

\item{taux}{Generates random gaps in time series. Parameter \code{taux}
defines the ratio of data to be kept (e.g. for \eqn{taux=0.75}, 75 percents
of the data are kept).}

\item{freq}{Subsamples the time series. Parameter \code{freq} defines the
periodicity of data kept (e.g. for \eqn{freq=3}, 1 data out of 3 is kept).}

\item{variables}{Defines which variables must be generated.}

\item{method}{Defines the numerical integration method to be used.
The fourth-order Runge-Kutta method is used by default
(\code{method = 'rk4'}). Other method may be used (such as \code{'ode45'}
or \code{'lsoda'}), see function \code{ode} from package \code{deSolve}
for details.}
}
\value{
A list of two variables: \cr

\code{$donnees} The integrated trajectory (first column is the time,
next columns are the model variables) \cr

\code{$bruitM} The level of dynamical noise \cr

\code{$bruitA} The level of additive noise \cr

\code{$vectBruitM} The vector of the dynamical noise used to produce
the time series \cr

\code{$vectBruitA} The vector of the additive noise used to produce
the time series \cr

\code{$ecart_type} The level standard deviation \cr
}
\description{
Generates time series from Ordinary Differential Equations
perturbed by dynamical and/or measurement noises
}
\examples{
#############
# Example 1 #
#############
# Rossler Model formulation
# The model dimension
nVar = 3
 # maximal polynomial degree
dMax = 2
a = 0.520
b = 2
c = 4
Eq1 <- c(0,-1, 0,-1, 0, 0, 0, 0, 0, 0)
Eq2 <- c(0, 0, 0, a, 0, 0, 1, 0, 0, 0)
Eq3 <- c(b,-c, 0, 0, 0, 0, 0, 1, 0, 0)
K <- cbind(Eq1, Eq2, Eq3)
# Edit the equations
visuEq(K, nVar, dMax)
# initial conditions
v0 <- c(-0.6, 0.6, 0.4)
# output time required
timeOut = (0:800)/50
# variance of additive noise
varBruitA = c(0,0,0)^2
# variance of multiplitive noise
varBruitM = c(2E-2, 0, 2E-2)^2
# numerical integration with noise
intgr <- numinoisy(v0, timeOut, K, varBruitA = varBruitA, varBruitM = varBruitM, freq = 1)
# Plot of the simulated time series obtained
dev.new()
plot(intgr$donnees[,2], intgr$donnees[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
dev.new()
par(mfrow = c(3, 1))
plot(intgr$donnees[,1], intgr$donnees[,2], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,2]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')
plot(intgr$donnees[,1], intgr$donnees[,3], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,3]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')
plot(intgr$donnees[,1], intgr$donnees[,4], type='l',
      main='phase portrait', xlab='x(t)', ylab = 'y(t)')
lines(intgr$donnees[,1], intgr$vectBruitM[,4]*10, type='l',
      main='phase portrait', xlab='x(t)', ylab = 'e(t)*10', col='red')

}
\author{
Sylvain Mangiarotti, Malika Chassan
}
